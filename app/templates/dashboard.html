<!DOCTYPE html>
<html>
<head>
    <title>üïπÔ∏è BSC Story Analysis Terminal</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            padding: 2em;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 2em 0;
        }
        
        .card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 1.5em;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .controls-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 1.5em;
            margin-bottom: 2em;
        }
        
        .controls-section h2 {
            color: #ff69b4;
            margin-bottom: 1em;
            font-size: 1.2em;
        }
        
        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 1em;
        }
        
        .control-row label {
            min-width: 120px;
            color: #00ffff;
        }
        
        .control-row select, .control-row button {
            margin-left: 10px;
        }
        
        .card-title {
            font-family: 'Press Start 2P', cursive;
            color: #ff69b4;
            font-size: 14px;
            margin-bottom: 1em;
            text-shadow: 0 0 10px #ff69b4;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            background: linear-gradient(45deg, rgba(255, 105, 180, 0.2), rgba(0, 255, 255, 0.2));
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 1em;
            text-align: center;
        }
        
        .stat-number {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            color: #ff69b4;
            text-shadow: 0 0 10px #ff69b4;
        }
        
        .stat-label {
            font-family: 'VT323', monospace;
            color: #00ffff;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .controls {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .control-group {
            display: inline-block;
            margin-right: 20px;
        }
        
        .control-group label {
            font-family: 'VT323', monospace;
            color: #00ff41;
            margin-right: 10px;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            display: inline-block;
            margin-right: 15px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            display: inline-block;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .axis {
            font-family: 'VT323', monospace;
            font-size: 12px;
            fill: #00ffff;
        }
        
        .bar {
            fill: #ff69b4;
            stroke: #00ffff;
            stroke-width: 1;
        }
        
        .bar:hover {
            fill: #00ffff;
        }
        
        .dot {
            stroke: #00ffff;
            stroke-width: 1;
        }
        
        .node {
            stroke: #ffff00;
            stroke-width: 2;
        }
        
        .link {
            stroke: #00ffff;
            stroke-opacity: 0.6;
        }
    </style>
</head>
<body>
    <h1>üïπÔ∏è Baby-Sitters Club Story Analysis Dashboard</h1>
    {% if error %}
        <div class="error">{{ error }}</div>
    {% endif %}
    
    <div class="controls-section">
        <h2>üìä Analysis Results</h2>
        <div class="control-row">
            <label for="result-selector">Select Analysis:</label>
            <select id="result-selector"></select>
            <button id="refresh-results">ÔøΩ Refresh</button>
        </div>
        <div id="result-info" style="margin-top: 10px; color: #00ffff; font-size: 14px;"></div>
    </div>
    
    <div class="dashboard">
        <div class="card full-width">
            <div class="card-title">üìä Overall Statistics</div>
            <div class="stats-grid" id="stats-overview"></div>
        </div>
        <div class="card">
            <div class="card-title">üéØ Goals Distribution</div>
            <div class="controls">
                <div class="control-group">
                    <label>Sort by:</label>
                    <select id="goals-sort">
                        <option value="frequency">Frequency</option>
                        <option value="alphabetical">Alphabetical</option>
                    </select>
                </div>
            </div>
            <div id="goals-chart"></div>
            <div class="legend" id="goals-legend"></div>
        </div>
        <div class="card">
            <div class="card-title">üìè Scene Length Distribution</div>
            <div class="controls">
                <div class="control-group">
                    <label>Bins:</label>
                    <input type="range" id="bins-slider" min="5" max="20" value="10">
                    <span id="bins-value">10</span>
                </div>
            </div>
            <div id="length-chart"></div>
        </div>
        <div class="card">
            <div class="card-title">‚ö° Goals vs Conflicts by Scene</div>
            <div class="controls">
                <div class="control-group">
                    <label>Size by:</label>
                    <select id="scatter-size">
                        <option value="length">Scene Length</option>
                        <option value="uniform">Uniform Size</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Color by:</label>
                    <select id="scatter-color">
                        <option value="book">Book</option>
                        <option value="goals">Goals Count</option>
                        <option value="conflicts">Conflicts Count</option>
                    </select>
                </div>
            </div>
            <div id="scatter-chart"></div>
        </div>
        <div class="card full-width">
            <div class="card-title"> Scene Details</div>
            <div class="controls">
                <div class="control-group">
                    <label>Book:</label>
                    <select id="book-filter">
                        <option value="all">All Books</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Scene:</label>
                    <select id="scene-filter">
                        <option value="all">All Scenes</option>
                    </select>
                </div>
            </div>
            <div id="scene-details"></div>
        </div>
    </div>
    </div>
    <div class="tooltip" id="tooltip"></div>
</head>
<body>
    <h1>üïπÔ∏è Baby-Sitters Club Story Analysis Terminal</h1>
        
        /* Chart styling */
        .axis text {
            fill: #00ff41;
            font-family: 'VT323', monospace;
        }
        
        .axis path,
        .axis line {
            stroke: #00ff41;
            stroke-width: 1;
        }
        
        .bar {
            stroke: #ff69b4;
            stroke-width: 1;
        }
        
        .dot {
            stroke: #00ffff;
            stroke-width: 1;
        }
        
        .node {
            stroke: #ffff00;
            stroke-width: 2;
        }
        
        .link {
            stroke: #00ffff;
            stroke-opacity: 0.6;
        }
    </style>
</head>
<body>
    <h1>üïπÔ∏è Baby-Sitters Club Story Analysis Terminal</h1>
    <div>
        <label for="corpus-selector">Select Corpus Folder:</label>
        <select id="corpus-selector"></select>
        <button id="load-corpus">Load Corpus</button>
    </div>
    <div class="container">
        <div class="card full-width">
            <div class="card-title">üìä Dataset Overview</div>
            <div class="stats-grid" id="stats-container"></div>
        </div>
        <div class="dashboard">
            <div class="card">
                <div class="card-title">üéØ Goal Categories Distribution</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Sort by:</label>
                        <select id="goal-sort">
                            <option value="count">Count</option>
                            <option value="alphabetical">Alphabetical</option>
                        </select>
                    </div>
                </div>
                <div id="goals-chart"></div>
                <div class="legend" id="goals-legend"></div>
            </div>
            <div class="card">
                <div class="card-title">üìè Scene Length Distribution</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Bins:</label>
                        <input type="range" id="bins-slider" min="5" max="20" value="10">
                        <span id="bins-value">10</span>
                    </div>
                </div>
                <div id="length-chart"></div>
            </div>
            <div class="card">
                <div class="card-title">‚ö° Goals vs Conflicts by Scene</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Size by:</label>
                        <select id="scatter-size">
                            <option value="length">Scene Length</option>
                            <option value="constant">Equal Size</option>
                        </select>
                    </div>
                </div>
                <div id="scatter-chart"></div>
            </div>
            <div class="card">
                <div class="card-title">üï∏Ô∏è Character Conflict Network</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Filter category:</label>
                        <select id="conflict-network-filter">
                            <option value="all">All Categories</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Force strength:</label>
                        <input type="range" id="conflict-force-slider" min="10" max="100" value="50">
                    </div>
                </div>
                <div id="conflict-network-chart"></div>
            </div>
            <div class="card">
                <div class="card-title">üé≠ Character-Goal Relationships</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Filter category:</label>
                        <select id="goal-network-filter">
                            <option value="all">All Categories</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Force strength:</label>
                        <input type="range" id="goal-force-slider" min="50" max="300" value="150">
                        <span id="goal-force-value">150</span>
                    </div>
                </div>
                <div id="goal-network-chart"></div>
            </div>
            <div class="card full-width">
                <div class="card-title">üîç Scene Details</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Select scene:</label>
                        <select id="scene-selector">
                            <option value="">Choose a scene...</option>
                        </select>
                    </div>
                </div>
                <div id="scene-details"></div>
            </div>
        </div>
    </div>
    <div class="tooltip" id="tooltip"></div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let data = null;
        let tooltip = d3.select("#tooltip");
        let availableResults = [];

        function fetchResults() {
            fetch('/list_results')
                .then(res => res.json())
                .then(results => {
                    availableResults = results;
                    const selector = document.getElementById('result-selector');
                    selector.innerHTML = '';
                    
                    if (results.length === 0) {
                        selector.innerHTML = '<option value="">No results available</option>';
                        return;
                    }
                    
                    results.forEach(r => {
                        const opt = document.createElement('option');
                        opt.value = r;
                        opt.textContent = r;
                        selector.appendChild(opt);
                    });
                    
                    // Auto-load specified result or latest result
                    let resultToLoad = null;
                    {% if auto_load_result %}
                    const autoLoadResult = "{{ auto_load_result }}";
                    if (results.includes(autoLoadResult)) {
                        resultToLoad = autoLoadResult;
                        selector.value = autoLoadResult;
                    }
                    {% endif %}
                    
                    if (!resultToLoad && results.length > 0) {
                        resultToLoad = results[0]; // Load the first (latest) result
                        selector.value = resultToLoad;
                    }
                    
                    if (resultToLoad) {
                        loadResult(resultToLoad);
                    }
                });
        }

        function loadResult(resultName = null) {
            const result = resultName || document.getElementById('result-selector').value;
            if (!result) return;
            
            fetch(`/preview_result?name=${encodeURIComponent(result)}`)
                .then(res => res.json())
                .then(loadedData => {
                    data = loadedData;
                    showResultInfo(result);
                    initializeVisualization();
                })
                .catch(err => {
                    console.error('Error loading result:', err);
                    document.getElementById('result-info').innerHTML = '<span style="color: #ff6b6b;">Error loading result</span>';
                });
        }
        
        function showResultInfo(resultName) {
            if (!data || !data.books) return;
            
            const info = document.getElementById('result-info');
            const bookCount = data.books.length;
            const totalScenes = data.books.reduce((sum, book) => sum + (book.scenes?.length || 0), 0);
            
            info.innerHTML = `
                <strong>üìö Books:</strong> ${bookCount} | 
                <strong>üé¨ Scenes:</strong> ${totalScenes} | 
                <strong>üìÑ File:</strong> ${resultName}
            `;
        }

        function initializeVisualization() {
            if (!data || !data.books || data.books.length === 0) {
                document.getElementById('result-info').innerHTML = '<span style="color: #ff6b6b;">No data available in this result</span>';
                return;
            }
            
            initializeStats();
            initializeControls();
            initializeSceneFilters();
            updateGoalsChart();
            updateLengthChart();
            updateScatterChart();
            updateNetworkChart();
            updateGoalNetworkChart();
            updateSceneDetails();
        }

        function initializeStats() {
            if (!data || !data.books) return;
            
            const stats = document.getElementById('stats-overview');
            const totalBooks = data.books.length;
            const totalScenes = data.books.reduce((sum, book) => sum + (book.scenes?.length || 0), 0);
            const avgScenesPerBook = totalBooks > 0 ? (totalScenes / totalBooks).toFixed(1) : 0;
            
            stats.innerHTML = `
                <div class="stat-item">
                    <div class="stat-number">${totalBooks}</div>
                    <div class="stat-label">Books</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${totalScenes}</div>
                    <div class="stat-label">Total Scenes</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${avgScenesPerBook}</div>
                    <div class="stat-label">Avg Scenes/Book</div>
                </div>
            `;
        }

        function initializeControls() {
            // Add event listeners for conflict network controls
            const conflictNetworkFilter = document.getElementById('conflict-network-filter');
            const conflictForceSlider = document.getElementById('conflict-force-slider');
            
            if (conflictNetworkFilter && !conflictNetworkFilter.hasAttribute('data-listeners-added')) {
                conflictNetworkFilter.addEventListener('change', updateNetworkChart);
                conflictNetworkFilter.setAttribute('data-listeners-added', 'true');
            }
            
            if (conflictForceSlider && !conflictForceSlider.hasAttribute('data-listeners-added')) {
                conflictForceSlider.addEventListener('input', updateNetworkChart);
                conflictForceSlider.setAttribute('data-listeners-added', 'true');
            }
        }

        function updateGoalsChart() {
            const container = document.getElementById('goals-chart');
            container.innerHTML = ''; // Clear previous content
            
            if (!data || !data.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goals data available</div>';
                return;
            }

            // Aggregate goals by category across all books
            const goalCategories = {};
            const motivationTypes = {};
            
            data.books.forEach(book => {
                if (book.goals) {
                    book.goals.forEach(goal => {
                        // Count by category
                        if (goal.category) {
                            goalCategories[goal.category] = (goalCategories[goal.category] || 0) + 1;
                        }
                        // Count by motivation type  
                        if (goal.motivation_type) {
                            motivationTypes[goal.motivation_type] = (motivationTypes[goal.motivation_type] || 0) + 1;
                        }
                    });
                }
            });

            const width = container.clientWidth || 600;
            const height = 300;
            const margin = { top: 20, right: 20, bottom: 40, left: 80 };

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Prepare data for bar chart
            const categoryData = Object.entries(goalCategories)
                .map(([category, count]) => ({ category, count }))
                .sort((a, b) => b.count - a.count);

            if (categoryData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goal categories found</div>';
                return;
            }

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(categoryData, d => d.count)])
                .range([margin.left, width - margin.right]);

            const yScale = d3.scaleBand()
                .domain(categoryData.map(d => d.category))
                .range([margin.top, height - margin.bottom])
                .padding(0.1);

            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // Add bars
            svg.selectAll('rect')
                .data(categoryData)
                .enter()
                .append('rect')
                .attr('x', margin.left)
                .attr('y', d => yScale(d.category))
                .attr('width', d => xScale(d.count) - margin.left)
                .attr('height', yScale.bandwidth())
                .attr('fill', d => colorScale(d.category))
                .attr('stroke', '#fff')
                .attr('stroke-width', 1);

            // Add labels
            svg.selectAll('.bar-label')
                .data(categoryData)
                .enter()
                .append('text')
                .attr('class', 'bar-label')
                .attr('x', d => xScale(d.count) + 5)
                .attr('y', d => yScale(d.category) + yScale.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('font-size', '12px')
                .attr('fill', '#00ffff')
                .text(d => d.count);

            // Add category labels
            svg.selectAll('.category-label')
                .data(categoryData)
                .enter()
                .append('text')
                .attr('class', 'category-label')
                .attr('x', margin.left - 10)
                .attr('y', d => yScale(d.category) + yScale.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('font-size', '11px')
                .attr('fill', '#00ffff')
                .attr('text-anchor', 'end')
                .text(d => d.category);

            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#00ffff')
                .text('Goal Categories Distribution');

            // Add axis labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#00ffff')
                .text('Number of Goals');
        }

        function updateLengthChart() {
            // Simple scene length visualization
            const container = document.getElementById('length-chart');
            if (!data || !data.books) return;
            
            const allScenes = data.books.flatMap(book => book.scenes || []);
            const lengths = allScenes.map(scene => scene.text_length || 0);
            
            container.innerHTML = `
                <div style="padding: 20px; color: #00ffff;">
                    <p>üìè Scene Length Analysis:</p>
                    <p>Total scenes: ${lengths.length}</p>
                    <p>Avg length: ${lengths.length > 0 ? Math.round(lengths.reduce((a,b) => a+b, 0) / lengths.length) : 0} chars</p>
                    <p>Min: ${Math.min(...lengths)} | Max: ${Math.max(...lengths)}</p>
                </div>
            `;
        }

        function updateScatterChart() {
            const container = document.getElementById('scatter-chart');
            container.innerHTML = ''; // Clear previous content
            
            if (!data || !data.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No data available for scatter plot</div>';
                return;
            }

            // Prepare data: goals vs conflicts per book
            const plotData = data.books.map(book => ({
                title: book.book_title || book.book_id,
                goals: book.goal_count || (book.goals ? book.goals.length : 0),
                conflicts: book.conflict_count || (book.conflicts ? book.conflicts.length : 0),
                scenes: book.scene_count || (book.scenes ? book.scenes.length : 0)
            })).filter(d => d.goals > 0 || d.conflicts > 0);

            if (plotData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goals or conflicts data found</div>';
                return;
            }

            const width = container.clientWidth || 600;
            const height = 300;
            const margin = { top: 20, right: 20, bottom: 60, left: 60 };

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(plotData, d => d.goals)])
                .range([margin.left, width - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(plotData, d => d.conflicts)])
                .range([height - margin.bottom, margin.top]);

            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(plotData, d => d.scenes)])
                .range([3, 12]);

            // Add dots
            svg.selectAll('circle')
                .data(plotData)
                .enter()
                .append('circle')
                .attr('cx', d => xScale(d.goals))
                .attr('cy', d => yScale(d.conflicts))
                .attr('r', d => sizeScale(d.scenes))
                .attr('fill', '#ff69b4')
                .attr('stroke', '#00ffff')
                .attr('stroke-width', 1)
                .attr('opacity', 0.7);

            // Add tooltips
            svg.selectAll('circle')
                .append('title')
                .text(d => `${d.title}\nGoals: ${d.goals}\nConflicts: ${d.conflicts}\nScenes: ${d.scenes}`);

            // Add axes
            const xAxis = d3.axisBottom(xScale).ticks(5);
            const yAxis = d3.axisLeft(yScale).ticks(5);

            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .call(xAxis)
                .selectAll('text')
                .attr('fill', '#00ffff');

            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(yAxis)
                .selectAll('text')
                .attr('fill', '#00ffff');

            // Style axes
            svg.selectAll('.domain, .tick line')
                .attr('stroke', '#00ffff');

            // Add axis labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#00ffff')
                .text('Number of Goals');

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#00ffff')
                .text('Number of Conflicts');

            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#00ffff')
                .text('Goals vs Conflicts by Book');
        }

        function updateNetworkChart() {
            const container = document.getElementById('conflict-network-chart');
            container.innerHTML = ''; // Clear previous content
            
            console.log('Network chart data:', data); // Debug log
            
            if (!data || !data.conflict_network) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No network data available</div>';
                return;
            }

            console.log('Conflict network:', data.conflict_network); // Debug log

            const width = container.clientWidth || 600;
            const height = 400;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Prepare nodes and links from conflict_network data
            let allCharacters = new Set();
            
            // Collect all characters from conflicts
            data.conflict_network.forEach(conflict => {
                if (conflict.characters && Array.isArray(conflict.characters)) {
                    conflict.characters.forEach(char => allCharacters.add(char));
                }
            });
            
            // Also add characters from character_books if available
            if (data.character_books) {
                Object.keys(data.character_books).forEach(char => allCharacters.add(char));
            }
            
            // Create nodes
            const nodes = Array.from(allCharacters).map(char => ({
                id: char,
                name: char,
                books: data.character_books && data.character_books[char] ? data.character_books[char] : [],
                bookCount: data.character_books && data.character_books[char] ? data.character_books[char].length : 1
            }));

            // Create links from conflict data
            const links = [];
            data.conflict_network.forEach(conflict => {
                if (conflict.characters && Array.isArray(conflict.characters) && conflict.characters.length >= 2) {
                    // Create links between all pairs of characters in the conflict
                    for (let i = 0; i < conflict.characters.length; i++) {
                        for (let j = i + 1; j < conflict.characters.length; j++) {
                            const char1 = conflict.characters[i];
                            const char2 = conflict.characters[j];
                            
                            // Find existing link or create new one
                            let existingLink = links.find(link => 
                                (link.source === char1 && link.target === char2) ||
                                (link.source === char2 && link.target === char1)
                            );
                            
                            if (existingLink) {
                                existingLink.conflicts.push(conflict);
                                existingLink.conflictCount++;
                            } else {
                                links.push({
                                    source: char1,
                                    target: char2,
                                    conflicts: [conflict],
                                    conflictCount: 1
                                });
                            }
                        }
                    }
                }
            });

            console.log('Nodes:', nodes); // Debug log
            console.log('Links:', links); // Debug log

            if (nodes.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No characters found in conflict data</div>';
                return;
            }

            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));

            // Color scale based on book count
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // Add links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#555')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.conflictCount) + 1);

            // Add nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => Math.sqrt(d.bookCount) * 3 + 8)
                .attr('fill', d => colorScale(d.bookCount))
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.name)
                .attr('font-size', '10px')
                .attr('font-family', 'Arial, sans-serif')
                .attr('fill', '#00ffff')
                .attr('text-anchor', 'middle')
                .attr('dy', -15);

            // Add tooltips
            node.append('title')
                .text(d => `${d.name}\nBooks: ${d.books.join(', ')}\nBook count: ${d.bookCount}`);

            link.append('title')
                .text(d => `${d.source.id} ‚Üî ${d.target.id}\nConflicts: ${d.conflictCount}`);

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function updateGoalNetworkChart() {
            const container = document.getElementById('goal-network-chart');
            container.innerHTML = ''; // Clear previous content
            
            if (!data || !data.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No character-goal data available</div>';
                return;
            }

            // Collect all goals from all books
            const allGoals = [];
            data.books.forEach(book => {
                if (book.goals) {
                    allGoals.push(...book.goals);
                }
            });

            if (allGoals.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goals found</div>';
                return;
            }

            const filterCategory = document.getElementById('goal-network-filter').value;
            const forceStrength = +document.getElementById('goal-force-slider').value;

            // Filter goals by category
            let filteredGoals = allGoals;
            if (filterCategory !== "all") {
                filteredGoals = allGoals.filter(g => g.category === filterCategory);
            }

            // Create nodes and links
            const characters = [...new Set(filteredGoals.map(g => g.character))];
            const categories = [...new Set(filteredGoals.map(g => g.category))];

            const nodes = [
                ...characters.map(c => ({ id: c, type: "character", group: "character" })),
                ...categories.map(c => ({ id: c, type: "category", group: "category" }))
            ];

            const links = filteredGoals.map(g => ({
                source: g.character,
                target: g.category,
                goal_text: g.goal_text
            }));

            const width = container.clientWidth || 400;
            const height = 300;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-forceStrength))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(15));

            // Color scales
            const characterColor = '#3498db';
            const categoryColors = d3.scaleOrdinal(d3.schemeCategory10);

            // Add links
            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("stroke", "#555")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", 1);

            // Add nodes
            const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", d => d.type === "character" ? 8 : 12)
                .attr("fill", d => d.type === "character" ? characterColor : categoryColors(d.id))
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .call(d3.drag()
                    .on("start", goalDragstarted)
                    .on("drag", goalDragged)
                    .on("end", goalDragended));

            // Add tooltips
            node.append('title')
                .text(d => `${d.id}\nType: ${d.type}`);

            // Add labels
            const label = svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter()
                .append("text")
                .text(d => d.id)
                .style("font-size", "10px")
                .style("text-anchor", "middle")
                .style("fill", "#00ff41")
                .attr("dy", -15);

            // Update positions on tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            // Drag functions for goal network
            function goalDragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function goalDragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function goalDragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // Populate filter dropdown
            const goalNetworkFilter = document.getElementById('goal-network-filter');
            const existingOptions = Array.from(goalNetworkFilter.options).map(opt => opt.value);
            
            categories.forEach(category => {
                if (!existingOptions.includes(category)) {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                    goalNetworkFilter.appendChild(option);
                }
            });

            // Add event listeners if not already added
            if (!goalNetworkFilter.hasAttribute('data-listeners-added')) {
                goalNetworkFilter.addEventListener('change', updateGoalNetworkChart);
                document.getElementById('goal-force-slider').addEventListener('input', function() {
                    document.getElementById('goal-force-value').textContent = this.value;
                    updateGoalNetworkChart();
                });
                goalNetworkFilter.setAttribute('data-listeners-added', 'true');
            }
        }

        function initializeSceneFilters() {
            // Populate book filter
            const bookFilter = document.getElementById('book-filter');
            bookFilter.innerHTML = '<option value="all">All Books</option>';
            
            if (data && data.books) {
                data.books.forEach(book => {
                    const option = document.createElement('option');
                    option.value = book.book_id;
                    option.textContent = book.book_title || book.book_id;
                    bookFilter.appendChild(option);
                });
            }
            
            // Populate scene filter based on selected book
            updateSceneFilter();
            
            // Add event listeners
            bookFilter.addEventListener('change', updateSceneFilter);
            document.getElementById('scene-filter').addEventListener('change', updateSceneDetails);
        }
        
        function updateSceneFilter() {
            const bookFilter = document.getElementById('book-filter');
            const sceneFilter = document.getElementById('scene-filter');
            const selectedBook = bookFilter.value;
            
            sceneFilter.innerHTML = '<option value="all">All Scenes</option>';
            
            if (data && data.books && selectedBook !== 'all') {
                const book = data.books.find(b => b.book_id === selectedBook);
                if (book && book.scenes) {
                    book.scenes.forEach(scene => {
                        const option = document.createElement('option');
                        option.value = scene.scene_id;
                        const narrator = scene.narrator ? ` (${scene.narrator})` : '';
                        option.textContent = `Scene ${scene.scene_num}${narrator}`;
                        sceneFilter.appendChild(option);
                    });
                }
            } else if (data && data.books) {
                // Show all scenes from all books
                data.books.forEach(book => {
                    if (book.scenes) {
                        book.scenes.forEach(scene => {
                            const option = document.createElement('option');
                            option.value = scene.scene_id;
                            const narrator = scene.narrator ? ` (${scene.narrator})` : '';
                            option.textContent = `${book.book_title || book.book_id} - Scene ${scene.scene_num}${narrator}`;
                            sceneFilter.appendChild(option);
                        });
                    }
                });
            }
            
            updateSceneDetails();
        }

        function updateSceneDetails() {
            // Scene details with actual data
            const container = document.getElementById('scene-details');
            if (!data || !data.books) return;
            
            const selectedBook = document.getElementById('book-filter').value;
            const selectedScene = document.getElementById('scene-filter').value;
            
            let html = '<div style="color: #00ffff; padding: 10px;">';
            
            // Filter books based on selection
            const booksToShow = selectedBook === 'all' ? data.books : data.books.filter(b => b.book_id === selectedBook);
            
            booksToShow.forEach(book => {
                html += `<h4 style="color: #ff69b4;">${book.book_title || book.book_id}</h4>`;
                if (book.scenes && book.scenes.length > 0) {
                    // Filter scenes based on selection
                    const scenesToShow = selectedScene === 'all' ? book.scenes : book.scenes.filter(s => s.scene_id === selectedScene);
                    
                    scenesToShow.forEach(scene => {
                        // Create preview and calculate length from scene.text
                        const textContent = scene.text || '';
                        const preview = textContent.substring(0, 150) + (textContent.length > 150 ? '...' : '');
                        const length = textContent.length;
                        const narrator = scene.narrator ? ` (Narrator: ${scene.narrator})` : '';
                        
                        html += `
                            <div style="margin: 10px 0; padding: 10px; border: 1px solid #00ff41; border-radius: 5px;">
                                <strong>Scene ${scene.scene_num}${narrator}:</strong><br>
                                <em>${preview || 'No preview available'}</em><br>
                                <small>Length: ${length} characters | Chapter: ${scene.chapter_num || 'N/A'}</small>
                            </div>
                        `;
                    });
                } else {
                    html += '<p>No scenes available</p>';
                }
            });
            html += '</div>';
            container.innerHTML = html;
        }

        // Event listeners
        document.getElementById('result-selector').addEventListener('change', function() {
            loadResult(this.value);
        });
        
        document.getElementById('refresh-results').addEventListener('click', fetchResults);
        
        // Initialize
        fetchResults();

        // Visualization functions (same as index.html)
        // ...existing code for D3 visualizations from index.html...
    </script>
    <a href="/">Back to Dashboard</a>
</body>
</html>
