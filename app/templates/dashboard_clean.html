<!DOCTYPE html>
<html>
<head>
    <title>üïπÔ∏è BSC Story Analysis Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        body {
            padding: 2em;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 2em 0;
        }
        
        .card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 1.5em;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .controls-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 1.5em;
            margin: 1em 0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0.5em 0;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0.5em 0;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 1em;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .control-row label {
            min-width: 120px;
            color: #00ffff;
        }
        
        .control-row select, .control-row button {
            margin-left: 10px;
        }
        
        .card-title {
            font-family: 'Press Start 2P', cursive;
            color: #ff69b4;
            font-size: 14px;
            margin-bottom: 1em;
            text-shadow: 0 0 10px #ff69b4;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .stat-card {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff69b4;
            display: block;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #00ffff;
            text-transform: uppercase;
        }
        
        .legend {
            margin-top: 1em;
            font-size: 11px;
        }
        
        .legend-item {
            display: inline-block;
            margin: 0 10px 5px 0;
        }
        
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
            padding: 1em;
            border-radius: 5px;
            margin: 1em 0;
        }
        
        select, input, button {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'VT323', monospace;
            font-size: 14px;
        }
        
        button {
            background: rgba(0, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .chart-container {
            position: relative;
            min-height: 300px;
        }
        
        /* Fullscreen functionality */
        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            display: none;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .fullscreen-content {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .close-fullscreen {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 107, 180, 0.3);
            border: 1px solid #ff69b4;
            color: #ff69b4;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 14px;
            z-index: 10000;
        }
        
        .close-fullscreen:hover {
            background: rgba(255, 107, 180, 0.5);
            box-shadow: 0 0 10px rgba(255, 107, 180, 0.3);
        }
        
        /* Scene details styling */
        .scene-info {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .scene-header {
            font-size: 16px;
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 10px;
        }
        
        .scene-meta {
            font-size: 12px;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .goals-conflicts {
            margin: 10px 0;
        }
        
        .goals-conflicts h4 {
            color: #ff69b4;
            margin: 5px 0;
        }
        
        .goal-item, .conflict-item {
            background: rgba(255, 107, 180, 0.1);
            border-left: 3px solid #ff69b4;
            padding: 8px;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .evidence-text {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ffff;
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: #00ffff;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>üïπÔ∏è Baby-Sitters Club Story Analysis Dashboard</h1>
    {% if error %}
        <div class="error">{{ error }}</div>
    {% endif %}
    
    <div class="controls-section">
        <h2>üìä Analysis Results</h2>
        <div class="control-row">
            <label for="result-selector">Choose Results:</label>
            <select id="result-selector"></select>
            <button id="load-result">Load Analysis</button>
        </div>
        {% if auto_load_result %}
        <script>
            window.addEventListener('DOMContentLoaded', function() {
                document.getElementById('result-selector').value = '{{ auto_load_result }}';
                document.getElementById('load-result').click();
            });
        </script>
        {% endif %}
    </div>

    <div class="dashboard">
        <div class="card">
            <div class="card-title">üéØ Goal Categories Distribution</div>
            <div class="controls">
                <div class="control-group">
                    <label>Sort by:</label>
                    <select id="goal-sort">
                        <option value="count">Count</option>
                        <option value="alphabetical">Alphabetical</option>
                    </select>
                </div>
            </div>
            <div id="goals-chart" class="chart-container">
                <button class="fullscreen-btn" onclick="openFullscreen('goals-chart')">üîç</button>
            </div>
            <div class="legend" id="goals-legend"></div>
        </div>
        <div class="card">
            <div class="card-title">üìè Scene Length Distribution</div>
            <div class="controls">
                <div class="control-group">
                    <label>Bins:</label>
                    <input type="range" id="bins-slider" min="5" max="20" value="10">
                    <span id="bins-value">10</span>
                </div>
            </div>
            <div id="length-chart" class="chart-container">
                <button class="fullscreen-btn" onclick="openFullscreen('length-chart')">üîç</button>
            </div>
        </div>
        <div class="card">
            <div class="card-title">‚ö° Goals vs Conflicts by Scene</div>
            <div class="controls">
                <div class="control-group">
                    <label>Size by:</label>
                    <select id="scatter-size">
                        <option value="length">Scene Length</option>
                        <option value="constant">Equal Size</option>
                    </select>
                </div>
            </div>
            <div id="scatter-chart" class="chart-container">
                <button class="fullscreen-btn" onclick="openFullscreen('scatter-chart')">üîç</button>
            </div>
        </div>
        <div class="card">
            <div class="card-title">üï∏Ô∏è Character Conflict Network</div>
            <div class="controls">
                <div class="control-group">
                    <label>Filter by character:</label>
                    <select id="character-filter">
                        <option value="all">All Characters</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Conflict threshold:</label>
                    <input type="range" id="conflict-threshold" min="1" max="10" value="1">
                    <span id="threshold-value">1</span>
                </div>
            </div>
            <div id="conflict-network-chart" class="chart-container">
                <button class="fullscreen-btn" onclick="openFullscreen('conflict-network-chart')">üîç</button>
            </div>
        </div>
        <div class="card">
            <div class="card-title">üé≠ Character-Goal Network</div>
            <div class="controls">
                <div class="control-group">
                    <label>Filter by category:</label>
                    <select id="goal-filter">
                        <option value="all">All Categories</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Force strength:</label>
                    <input type="range" id="goal-force-slider" min="50" max="300" value="150">
                    <span id="goal-force-value">150</span>
                </div>
            </div>
            <div id="goal-network-chart" class="chart-container">
                <button class="fullscreen-btn" onclick="openFullscreen('goal-network-chart')">üîç</button>
            </div>
        </div>
        <div class="card full-width">
            <div class="card-title">üîç Scene Details</div>
            <div class="controls">
                <div class="control-group">
                    <label>Select scene:</label>
                    <select id="scene-selector">
                        <option value="">Choose a scene...</option>
                    </select>
                </div>
            </div>
            <div id="scene-details"></div>
        </div>
        <div class="card full-width">
            <div class="card-title">üìä Dataset Overview</div>
            <div class="stats-grid" id="stats-container"></div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <!-- Fullscreen overlay template -->
    <div class="fullscreen-overlay" id="fullscreen-overlay">
        <div class="fullscreen-content" id="fullscreen-content">
            <button class="close-fullscreen" onclick="closeFullscreen()">‚úï Close</button>
            <div id="fullscreen-chart-container"></div>
        </div>
    </div>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let data = null;
        let tooltip = d3.select("#tooltip");
        let availableResults = [];

        // Fullscreen functionality
        function openFullscreen(chartId) {
            const overlay = document.getElementById('fullscreen-overlay');
            const container = document.getElementById('fullscreen-chart-container');
            
            // Clear previous content
            container.innerHTML = '';
            
            // Create fullscreen chart container
            const fullscreenChart = document.createElement('div');
            fullscreenChart.id = chartId + '-fullscreen';
            fullscreenChart.style.width = '100%';
            fullscreenChart.style.height = '80vh';
            container.appendChild(fullscreenChart);
            
            // Show overlay
            overlay.style.display = 'block';
            
            // Re-render the chart in fullscreen
            setTimeout(() => {
                redrawChart(chartId + '-fullscreen', chartId);
            }, 100);
        }
        
        function closeFullscreen() {
            const overlay = document.getElementById('fullscreen-overlay');
            overlay.style.display = 'none';
        }
        
        function redrawChart(fullscreenId, originalId) {
            const container = document.getElementById(fullscreenId);
            if (!container || !data) return;
            
            // Clear existing content
            d3.select('#' + fullscreenId).selectAll('*').remove();
            
            // Get chart dimensions for fullscreen
            const width = window.innerWidth - 100;
            const height = window.innerHeight - 100;
            
            // Redraw based on chart type
            switch(originalId) {
                case 'goals-chart':
                    updateGoalsChart(data, fullscreenId, width, height);
                    break;
                case 'length-chart':
                    updateLengthChart(data, fullscreenId, width, height);
                    break;
                case 'scatter-chart':
                    updateScatterChart(data, fullscreenId, width, height);
                    break;
                case 'conflict-network-chart':
                    updateNetworkChart(data, fullscreenId, width, height);
                    break;
                case 'goal-network-chart':
                    updateGoalNetworkChart(data, fullscreenId, width, height);
                    break;
            }
        }

        function fetchResults() {
            fetch('/list_results')
                .then(res => res.json())
                .then(results => {
                    availableResults = results;
                    const selector = document.getElementById('result-selector');
                    selector.innerHTML = '';
                    
                    if (results.length === 0) {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No results available';
                        selector.appendChild(option);
                        return;
                    }
                    
                    results.forEach(result => {
                        const option = document.createElement('option');
                        option.value = result.name;
                        option.textContent = `${result.name} (${result.modified})`;
                        selector.appendChild(option);
                    });
                })
                .catch(err => console.error('Error fetching results:', err));
        }

        function loadResult() {
            const selector = document.getElementById('result-selector');
            const selectedResult = selector.value;
            
            if (!selectedResult) {
                alert('Please select a result to load');
                return;
            }
            
            fetch(`/preview_result?name=${encodeURIComponent(selectedResult)}`)
                .then(res => res.json())
                .then(result => {
                    data = result;
                    updateVisualization();
                })
                .catch(err => {
                    console.error('Error loading result:', err);
                    alert('Error loading result');
                });
        }

        function updateVisualization() {
            if (!data) return;
            
            updateStatsContainer();
            updateGoalsChart();
            updateLengthChart();
            updateScatterChart();
            updateNetworkChart();
            updateGoalNetworkChart();
            updateSceneSelector();
            setupEventListeners();
        }

        function updateStatsContainer() {
            const container = document.getElementById('stats-container');
            container.innerHTML = '';
            
            if (!data || !data.books) return;
            
            // Calculate statistics from nested data
            let totalScenes = 0;
            let totalGoals = 0;
            let totalConflicts = 0;
            const characters = new Set();
            
            data.books.forEach(book => {
                if (book.scenes) {
                    totalScenes += book.scenes.length;
                }
                if (book.goals) {
                    totalGoals += book.goals.length;
                    book.goals.forEach(goal => {
                        if (goal.character) characters.add(goal.character);
                    });
                }
                if (book.conflicts) {
                    totalConflicts += book.conflicts.length;
                    book.conflicts.forEach(conflict => {
                        if (conflict.character1) characters.add(conflict.character1);
                        if (conflict.character2) characters.add(conflict.character2);
                    });
                }
            });
            
            const stats = [
                { label: 'Books', value: data.books.length },
                { label: 'Scenes', value: totalScenes },
                { label: 'Goals', value: totalGoals },
                { label: 'Conflicts', value: totalConflicts },
                { label: 'Characters', value: characters.size }
            ];
            
            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <span class="stat-value">${stat.value.toLocaleString()}</span>
                    <span class="stat-label">${stat.label}</span>
                `;
                container.appendChild(card);
            });
        }

        function updateGoalsChart(chartData = data, containerId = 'goals-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear previous content
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goals data available</div>';
                return;
            }

            // Aggregate goals by category across all books
            const goalCategories = {};
            
            chartData.books.forEach(book => {
                if (book.goals) {
                    book.goals.forEach(goal => {
                        if (goal.category) {
                            goalCategories[goal.category] = (goalCategories[goal.category] || 0) + 1;
                        }
                    });
                }
            });

            const chartWidth = width;
            const chartHeight = height;
            const margin = { top: 20, right: 20, bottom: 40, left: 80 };

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            // Prepare data for bar chart
            const categoryData = Object.entries(goalCategories)
                .map(([category, count]) => ({ category, count }))
                .sort((a, b) => b.count - a.count);

            if (categoryData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goal categories found</div>';
                return;
            }

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(categoryData, d => d.count)])
                .range([margin.left, chartWidth - margin.right]);

            const yScale = d3.scaleBand()
                .domain(categoryData.map(d => d.category))
                .range([margin.top, chartHeight - margin.bottom])
                .padding(0.1);

            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // Add bars
            svg.selectAll('rect')
                .data(categoryData)
                .enter()
                .append('rect')
                .attr('x', margin.left)
                .attr('y', d => yScale(d.category))
                .attr('width', d => xScale(d.count) - margin.left)
                .attr('height', yScale.bandwidth())
                .attr('fill', (d, i) => colorScale(i))
                .attr('stroke', '#ff69b4')
                .attr('stroke-width', 1);

            // Add labels
            svg.selectAll('.bar-label')
                .data(categoryData)
                .enter()
                .append('text')
                .attr('class', 'bar-label')
                .attr('x', d => xScale(d.count) + 5)
                .attr('y', d => yScale(d.category) + yScale.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('font-size', '12px')
                .attr('fill', '#00ffff')
                .text(d => d.count);

            // Add category labels
            svg.selectAll('.category-label')
                .data(categoryData)
                .enter()
                .append('text')
                .attr('class', 'category-label')
                .attr('x', margin.left - 10)
                .attr('y', d => yScale(d.category) + yScale.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('font-size', '11px')
                .attr('fill', '#00ffff')
                .attr('text-anchor', 'end')
                .text(d => d.category);

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#00ffff')
                .text('Goal Categories Distribution');
        }

        function updateLengthChart(chartData = data, containerId = 'length-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene data available</div>';
                return;
            }

            // Collect scene lengths from all books
            const sceneLengths = [];
            chartData.books.forEach(book => {
                if (book.scenes) {
                    book.scenes.forEach(scene => {
                        if (scene.text) {
                            sceneLengths.push(scene.text.length);
                        }
                    });
                }
            });

            if (sceneLengths.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene text data found</div>';
                return;
            }

            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width;
            const chartHeight = height;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            // Create histogram
            const bins = d3.histogram()
                .domain(d3.extent(sceneLengths))
                .thresholds(10)(sceneLengths);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(sceneLengths))
                .range([margin.left, chartWidth - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([chartHeight - margin.bottom, margin.top]);

            // Add bars
            svg.selectAll('rect')
                .data(bins)
                .enter()
                .append('rect')
                .attr('x', d => xScale(d.x0))
                .attr('y', d => yScale(d.length))
                .attr('width', d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1))
                .attr('height', d => chartHeight - margin.bottom - yScale(d.length))
                .attr('fill', '#ff69b4')
                .attr('stroke', '#00ffff')
                .attr('stroke-width', 1);

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', '#00ffff')
                .text('Scene Length Distribution');
        }

        function updateScatterChart(chartData = data, containerId = 'scatter-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene data available</div>';
                return;
            }

            // Collect data points from all books
            const sceneData = [];
            chartData.books.forEach(book => {
                if (book.scenes) {
                    book.scenes.forEach(scene => {
                        const goalCount = scene.goals ? scene.goals.length : 0;
                        const conflictCount = scene.conflicts ? scene.conflicts.length : 0;
                        const textLength = scene.text ? scene.text.length : 0;
                        
                        sceneData.push({
                            goals: goalCount,
                            conflicts: conflictCount,
                            length: textLength,
                            book: book.title || 'Unknown',
                            scene: scene.title || 'Untitled Scene'
                        });
                    });
                }
            });

            if (sceneData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene data found</div>';
                return;
            }

            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width;
            const chartHeight = height;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(sceneData, d => d.goals))
                .range([margin.left, chartWidth - margin.right]);

            const yScale = d3.scaleLinear()
                .domain(d3.extent(sceneData, d => d.conflicts))
                .range([chartHeight - margin.bottom, margin.top]);

            const radiusScale = d3.scaleSqrt()
                .domain(d3.extent(sceneData, d => d.length))
                .range([3, 15]);

            // Add dots
            svg.selectAll('circle')
                .data(sceneData)
                .enter()
                .append('circle')
                .attr('cx', d => xScale(d.goals))
                .attr('cy', d => yScale(d.conflicts))
                .attr('r', d => radiusScale(d.length))
                .attr('fill', '#ff69b4')
                .attr('stroke', '#00ffff')
                .attr('stroke-width', 1)
                .attr('opacity', 0.7);

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', '#00ffff')
                .text('Goals vs Conflicts by Scene');
        }

        function updateNetworkChart(chartData = data, containerId = 'conflict-network-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (!chartData || !chartData.conflict_network) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No conflict network data available</div>';
                return;
            }

            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            const chartWidth = width;
            const chartHeight = height;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            // Process network data
            const nodes = chartData.conflict_network.nodes || [];
            const links = chartData.conflict_network.links || [];

            if (nodes.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No character nodes found</div>';
                return;
            }

            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(chartWidth / 2, chartHeight / 2));

            // Add links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('stroke', '#00ffff')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.weight || 1));

            // Add nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', d => Math.sqrt((d.conflicts || 1) * 10))
                .attr('fill', '#ff69b4')
                .attr('stroke', '#ffff00')
                .attr('stroke-width', 2);

            // Add labels
            const labels = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .attr('dy', -3)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#00ffff')
                .text(d => d.id);

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                labels
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', '#00ffff')
                .text('Character Conflict Network');
        }

        function updateGoalNetworkChart(chartData = data, containerId = 'goal-network-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goal data available</div>';
                return;
            }

            // Build character-goal network from books data
            const characterGoals = {};
            const goalCategories = new Set();
            
            chartData.books.forEach(book => {
                if (book.goals) {
                    book.goals.forEach(goal => {
                        if (goal.character && goal.category) {
                            if (!characterGoals[goal.character]) {
                                characterGoals[goal.character] = {};
                            }
                            characterGoals[goal.character][goal.category] = 
                                (characterGoals[goal.character][goal.category] || 0) + 1;
                            goalCategories.add(goal.category);
                        }
                    });
                }
            });

            if (Object.keys(characterGoals).length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No character-goal relationships found</div>';
                return;
            }

            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            const chartWidth = width;
            const chartHeight = height;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            // Create nodes and links
            const nodes = [];
            const links = [];

            // Add character nodes
            Object.keys(characterGoals).forEach(character => {
                nodes.push({ id: character, type: 'character', size: 20 });
            });

            // Add goal category nodes and links
            Array.from(goalCategories).forEach(category => {
                nodes.push({ id: category, type: 'goal', size: 15 });
                
                Object.keys(characterGoals).forEach(character => {
                    if (characterGoals[character][category]) {
                        links.push({
                            source: character,
                            target: category,
                            weight: characterGoals[character][category]
                        });
                    }
                });
            });

            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(chartWidth / 2, chartHeight / 2));

            // Add links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('stroke', '#00ffff')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.weight));

            // Add nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', d => d.size)
                .attr('fill', d => d.type === 'character' ? '#ff69b4' : '#00ffff')
                .attr('stroke', '#ffff00')
                .attr('stroke-width', 2);

            // Add labels
            const labels = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .attr('dy', -3)
                .attr('text-anchor', 'middle')
                .attr('font-size', '9px')
                .attr('fill', '#00ffff')
                .text(d => d.id);

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                labels
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', '#00ffff')
                .text('Character-Goal Network');
        }

        function updateSceneSelector() {
            const selector = document.getElementById('scene-selector');
            selector.innerHTML = '<option value="">Choose a scene...</option>';
            
            if (!data || !data.books) return;
            
            // Add first scene from first book by default instead of all scenes
            if (data.books.length > 0 && data.books[0].scenes && data.books[0].scenes.length > 0) {
                const firstBook = data.books[0];
                const firstScene = firstBook.scenes[0];
                const option = document.createElement('option');
                option.value = `0-0`; // book index - scene index
                option.textContent = `${firstBook.title || 'Book 1'} - ${firstScene.title || 'Scene 1'}`;
                option.selected = true;
                selector.appendChild(option);
                
                // Load this scene immediately
                updateSceneDetails(`0-0`);
            }
            
            // Add all other scenes
            data.books.forEach((book, bookIndex) => {
                if (book.scenes) {
                    book.scenes.forEach((scene, sceneIndex) => {
                        if (bookIndex === 0 && sceneIndex === 0) return; // Skip first scene as it's already added
                        
                        const option = document.createElement('option');
                        option.value = `${bookIndex}-${sceneIndex}`;
                        option.textContent = `${book.title || `Book ${bookIndex + 1}`} - ${scene.title || `Scene ${sceneIndex + 1}`}`;
                        selector.appendChild(option);
                    });
                }
            });
        }

        function updateSceneDetails(sceneId) {
            const container = document.getElementById('scene-details');
            container.innerHTML = '';
            
            if (!sceneId || !data || !data.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">Select a scene to view details</div>';
                return;
            }
            
            const [bookIndex, sceneIndex] = sceneId.split('-').map(Number);
            const book = data.books[bookIndex];
            const scene = book?.scenes?.[sceneIndex];
            
            if (!scene) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff0000;">Scene not found</div>';
                return;
            }
            
            const sceneInfo = document.createElement('div');
            sceneInfo.className = 'scene-info';
            
            // Scene header
            const header = document.createElement('div');
            header.className = 'scene-header';
            header.textContent = `${book.title || `Book ${bookIndex + 1}`} - ${scene.title || `Scene ${sceneIndex + 1}`}`;
            sceneInfo.appendChild(header);
            
            // Scene metadata
            const meta = document.createElement('div');
            meta.className = 'scene-meta';
            meta.innerHTML = `
                <strong>Chapter:</strong> ${scene.chapter || 'Unknown'} | 
                <strong>Narrator:</strong> ${scene.narrator || 'Unknown'} |
                <strong>Length:</strong> ${scene.text ? scene.text.length.toLocaleString() + ' characters' : 'No text'}
            `;
            sceneInfo.appendChild(meta);
            
            // Goals section
            if (scene.goals && scene.goals.length > 0) {
                const goalsSection = document.createElement('div');
                goalsSection.className = 'goals-conflicts';
                goalsSection.innerHTML = '<h4>üéØ Goals:</h4>';
                
                scene.goals.forEach(goal => {
                    const goalDiv = document.createElement('div');
                    goalDiv.className = 'goal-item';
                    goalDiv.innerHTML = `
                        <strong>${goal.character || 'Unknown'}:</strong> ${goal.description || 'No description'}<br>
                        <small><em>Category: ${goal.category || 'Uncategorized'} | Type: ${goal.motivation_type || 'Unknown'}</em></small>
                    `;
                    goalsSection.appendChild(goalDiv);
                });
                
                sceneInfo.appendChild(goalsSection);
            }
            
            // Conflicts section
            if (scene.conflicts && scene.conflicts.length > 0) {
                const conflictsSection = document.createElement('div');
                conflictsSection.className = 'goals-conflicts';
                conflictsSection.innerHTML = '<h4>‚öîÔ∏è Conflicts:</h4>';
                
                scene.conflicts.forEach(conflict => {
                    const conflictDiv = document.createElement('div');
                    conflictDiv.className = 'conflict-item';
                    conflictDiv.innerHTML = `
                        <strong>${conflict.character1 || 'Unknown'} vs ${conflict.character2 || 'Unknown'}:</strong> ${conflict.description || 'No description'}<br>
                        <small><em>Type: ${conflict.type || 'Unknown'} | Intensity: ${conflict.intensity || 'Unknown'}</em></small>
                    `;
                    conflictsSection.appendChild(conflictDiv);
                });
                
                sceneInfo.appendChild(conflictsSection);
            }
            
            // Text preview
            if (scene.text) {
                const textPreview = document.createElement('div');
                textPreview.innerHTML = '<h4>üìñ Text Preview:</h4>';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'evidence-text';
                // Show first 500 characters
                const previewText = scene.text.length > 500 ? 
                    scene.text.substring(0, 500) + '...' : 
                    scene.text;
                textDiv.textContent = previewText;
                textPreview.appendChild(textDiv);
                
                sceneInfo.appendChild(textPreview);
            }
            
            container.appendChild(sceneInfo);
        }

        function setupEventListeners() {
            // Scene selector
            const sceneSelector = document.getElementById('scene-selector');
            if (sceneSelector && !sceneSelector.hasAttribute('data-listeners-added')) {
                sceneSelector.addEventListener('change', (e) => updateSceneDetails(e.target.value));
                sceneSelector.setAttribute('data-listeners-added', 'true');
            }
            
            // Other controls...
            const goalSort = document.getElementById('goal-sort');
            if (goalSort && !goalSort.hasAttribute('data-listeners-added')) {
                goalSort.addEventListener('change', updateGoalsChart);
                goalSort.setAttribute('data-listeners-added', 'true');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('load-result').addEventListener('click', loadResult);
            fetchResults();
        });
    </script>
</body>
</html>
