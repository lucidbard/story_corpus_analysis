<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baby-Sitters Club Scene Analysis Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* CRT/Retro 80s-90s Baby-Sitters Club Theme */
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Orbitron:wght@400;700;900&family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'VT323', monospace;
            font-size: 18px;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
            color: #00ff41;
            margin: 0;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* CRT Screen Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 65, 0.03) 2px,
                rgba(0, 255, 65, 0.03) 4px
            );
            pointer-events: none;
            z-index: 1000;
        }

        /* CRT Flicker Animation */
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.98; }
        }

        body {
            animation: flicker 0.15s infinite linear;
        }

        h1 {
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            color: #ff69b4;
            text-shadow: 
                0 0 5px #ff69b4,
                0 0 10px #ff69b4,
                0 0 15px #ff69b4,
                0 0 20px #ff1493;
            margin-bottom: 0.3em;
            font-size: 2.2em;
            text-align: center;
            letter-spacing: 2px;
        }

        h2 {
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin: 0.5em 0 0.8em 0;
            font-size: 1.1em;
        }

        h3 {
            color: #ffff00;
            text-shadow: 0 0 8px #ffff00;
            margin: 0.8em 0;
            font-size: 1em;
        }

        /* Header styling */
        header {
            text-align: center;
            margin-bottom: 1em;
            padding: 1em;
        }

        /* Main container layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1em;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto auto;
            gap: 20px;
            margin-top: 20px;
        }

        /* Card styling with retro effect */
        .card {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff69b4;
            border-radius: 15px;
            padding: 1.5em;
            box-shadow: 
                0 0 15px rgba(255, 105, 180, 0.4),
                inset 0 0 15px rgba(0, 255, 65, 0.1);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 0 25px rgba(255, 105, 180, 0.6),
                inset 0 0 20px rgba(0, 255, 65, 0.15);
        }

        .card-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 15px;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            color: #00ffff;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            display: block;
            color: #ff69b4;
            text-shadow: 0 0 5px #ff69b4;
        }

        .stat-label {
            font-size: 0.9em;
            color: #00ff41;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        select, input {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 0.5em;
            border-radius: 5px;
            font-family: 'VT323', monospace;
            font-size: 16px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #ff69b4;
            box-shadow: 0 0 5px #ff69b4;
        }

        label {
            color: #00ffff;
            font-family: 'VT323', monospace;
            font-size: 16px;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px;
            border-radius: 5px;
            font-family: 'VT323', monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
        }

        /* Chart styling */
        .chart-container {
            min-height: 300px;
            position: relative;
        }

        /* SVG text styling */
        svg text {
            font-family: 'VT323', monospace;
            fill: #00ff41;
        }

        /* Axis styling */
        .axis line,
        .axis path {
            stroke: #00ff41;
        }

        .axis text {
            fill: #00ff41;
            font-family: 'VT323', monospace;
        }

        /* Link styling for network chart */
        .link {
            stroke: #555;
            stroke-opacity: 0.6;
        }

        .node {
            cursor: pointer;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .card {
                padding: 1em;
            }
        }
    </style>
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
            z-index: 1000;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .bar {
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .bar:hover {
            opacity: 0.8;
        }

        .axis text {
            font-size: 12px;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .scene-details {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
            line-height: 1.4;
        }

        .scene-text {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>üìö Baby-Sitters Club Story Analysis</h1>
        <p style="color: #00ffff; font-family: 'VT323', monospace; font-size: 1.2em;">Interactive Character & Goal Network Visualization</p>
    </header>

    <div class="container">
        <!-- Statistics Overview -->
        <div class="card full-width">
            <div class="card-title">üìä Dataset Overview</div>
            <div class="stats-grid" id="stats-container">
                <!-- Stats will be populated by JavaScript -->
            </div>
        </div>

        <div class="dashboard">
            <!-- Goal Categories Chart -->
            <div class="card">
                <div class="card-title">üéØ Goal Categories</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Sort by:</label>
                        <select id="goal-sort">
                            <option value="count">Count</option>
                            <option value="alphabetical">Alphabetical</option>
                        </select>
                    </div>
                </div>
                <div class="chart-container" id="goals-chart"></div>
            </div>

            <!-- Scene Length Distribution -->
            <div class="card">
                <div class="card-title">üìè Scene Length Analysis</div>
                <div class="chart-container" id="length-chart"></div>
            </div>

            <!-- Goals vs Conflicts Scatter Plot -->
            <div class="card">
                <div class="card-title">‚ö° Goals vs Conflicts</div>
                <div class="chart-container" id="scatter-chart"></div>
            </div>

            <!-- Character Conflict Network -->
            <div class="card">
                <div class="card-title">ÔøΩÔ∏è Character Conflict Network</div>
                <div class="chart-container" id="network-chart"></div>
            </div>

            <!-- Character-Goal Relationships -->
            <div class="card">
                <div class="card-title">üé≠ Character-Goal Relationships</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Filter category:</label>
                        <select id="goal-network-filter">
                            <option value="all">All Categories</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Force strength:</label>
                        <input type="range" id="goal-force-slider" min="50" max="300" value="150">
                        <span id="goal-force-value">150</span>
                    </div>
                </div>
                <div class="chart-container" id="goal-network-chart"></div>
            </div>

            <!-- Scene Details -->
            <div class="card">
                <div class="card-title">üìñ Scene Details</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Select scene:</label>
                        <select id="scene-selector">
                            <option value="">Choose a scene...</option>
                        </select>
                    </div>
                </div>
                <div id="scene-details"></div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
                    </div>
                </div>
                <div id="length-chart"></div>
            </div>

            <!-- Goals vs Conflicts Scatter -->
            <div class="card">
                <div class="card-title">‚ö° Goals vs Conflicts by Scene</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Size by:</label>
                        <select id="scatter-size">
                            <option value="length">Scene Length</option>
                            <option value="constant">Equal Size</option>
                        </select>
                    </div>
                </div>
                <div id="scatter-chart"></div>
            </div>

            <!-- Scene Details Panel -->
            <div class="card full-width">
                <div class="card-title">üîç Scene Details</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Select scene:</label>
                        <select id="scene-selector">
                            <option value="">Choose a scene...</option>
                        </select>
                    </div>
                </div>
                <div id="scene-details"></div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global variables
        let data = null;
        let tooltip = d3.select("#tooltip");

        // Color scales
        const colorScale = d3.scaleOrdinal()
            .domain(['academic', 'social', 'family', 'creative', 'babysitting', 'other', 'unknown'])
            .range(['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#95a5a6', '#34495e']);

        // Load data and initialize visualizations
        d3.json("scene_analysis_visualization.json").then(function(loadedData) {
            console.log("Raw loaded data:", loadedData);
            
            // Transform data if it's in the new format (has books array)
            if (loadedData.books) {
                // Load transformation function
                fetch('transform_data.js')
                    .then(response => response.text())
                    .then(scriptText => {
                        // Execute the transformation script
                        eval(scriptText);
                        data = transformData(loadedData);
                        console.log("Transformed data:", data);
                        initializeVisualization();
                    })
                    .catch(error => {
                        console.error('Error loading transformation script:', error);
                        // Fallback: use raw data
                        data = loadedData;
                        initializeVisualization();
                    });
            } else {
                // Data is already in the expected format
                data = loadedData;
                initializeVisualization();
            }
        }).catch(error => {
            console.error('Error loading data:', error);
            document.getElementById('main-container').innerHTML = 
                '<div style="text-align: center; padding: 50px; color: #e74c3c;">' +
                '<h2>Error Loading Data</h2>' +
                '<p>Could not load visualization data. Please ensure scene_analysis_visualization.json exists.</p>' +
                '</div>';
        });

        function initializeVisualization() {
            initializeStats();
            initializeControls();
            updateGoalsChart();
            updateLengthChart();
            updateScatterChart();
            updateNetworkChart();
            updateGoalNetworkChart();
            updateSceneDetails();
        }

        function initializeStats() {
            const stats = [
                { label: "Total Scenes", value: data.scenes.length, color: "#3498db" },
                { label: "Goals Identified", value: data.goals.length, color: "#2ecc71" },
                { label: "Conflicts Found", value: data.conflicts.length, color: "#e74c3c" },
                { label: "Goal Categories", value: Object.keys(data.categories.goals).length, color: "#f39c12" },
                { label: "Avg Goals/Scene", value: (data.goals.length / data.scenes.length).toFixed(1), color: "#9b59b6" },
                { label: "Avg Conflicts/Scene", value: (data.conflicts.length / data.scenes.length).toFixed(1), color: "#e67e22" }
            ];

            const statsContainer = d3.select("#stats-container");
            statsContainer.selectAll(".stat-item")
                .data(stats)
                .enter()
                .append("div")
                .attr("class", "stat-item")
                .style("background", d => `linear-gradient(135deg, ${d.color}, ${d3.color(d.color).darker(1)})`)
                .html(d => `<span class="stat-number">${d.value}</span><span class="stat-label">${d.label}</span>`);
        }

        function initializeControls() {
            // Populate scene selector
            const sceneSelector = d3.select("#scene-selector");
            sceneSelector.selectAll("option.scene-option")
                .data(data.scenes)
                .enter()
                .append("option")
                .attr("class", "scene-option")
                .attr("value", d => d.id)
                .text(d => `${d.id} (${d.goals_count} goals, ${d.conflicts_count} conflicts)`);

            // Populate goal network filter
            const goalNetworkFilter = d3.select("#goal-network-filter");
            const categories = Object.keys(data.categories.goals);
            goalNetworkFilter.selectAll("option.category-option")
                .data(categories)
                .enter()
                .append("option")
                .attr("class", "category-option")
                .attr("value", d => d)
                .text(d => d.charAt(0).toUpperCase() + d.slice(1));

            // Add event listeners
            d3.select("#goal-sort").on("change", updateGoalsChart);
            d3.select("#scene-selector").on("change", updateSceneDetails);
            
            // Goal network controls
            d3.select("#goal-network-filter").on("change", updateGoalNetworkChart);
            d3.select("#goal-force-slider").on("input", function() {
                d3.select("#goal-force-value").text(this.value);
                updateGoalNetworkChart();
            });
        }

        function updateGoalsChart() {
            const container = d3.select("#goals-chart");
            container.selectAll("*").remove();

            const sortBy = d3.select("#goal-sort").node().value;
            let goalData = Object.entries(data.categories.goals);
            
            if (sortBy === "alphabetical") {
                goalData.sort((a, b) => a[0].localeCompare(b[0]));
            } else {
                goalData.sort((a, b) => b[1] - a[1]);
            }

            const margin = { top: 20, right: 30, bottom: 40, left: 50 };
            const width = 350 - margin.left - margin.right;
            const height = 250 - margin.bottom - margin.top;

            const svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(goalData.map(d => d[0]))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(goalData, d => d[1])])
                .range([height, 0]);

            svg.selectAll(".bar")
                .data(goalData)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d[0]))
                .attr("width", x.bandwidth())
                .attr("y", d => y(d[1]))
                .attr("height", d => height - y(d[1]))
                .attr("fill", d => colorScale(d[0]))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `<strong>${d[0]}</strong><br>Count: ${d[1]}<br>Percentage: ${(d[1]/data.goals.length*100).toFixed(1)}%`);
                })
                .on("mouseout", hideTooltip);

            svg.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");

            svg.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y));

            // Update legend
            const legend = d3.select("#goals-legend");
            legend.selectAll("*").remove();
            
            const legendItems = legend.selectAll(".legend-item")
                .data(goalData)
                .enter()
                .append("div")
                .attr("class", "legend-item");

            legendItems.append("div")
                .attr("class", "legend-color")
                .style("background-color", d => colorScale(d[0]));

            legendItems.append("span")
                .text(d => `${d[0]} (${d[1]})`);
        }

        function updateLengthChart() {
            const container = d3.select("#length-chart");
            container.selectAll("*").remove();

            const bins = +d3.select("#bins-slider").node().value;
            const lengths = data.scenes.map(d => d.scene_length);

            const margin = { top: 20, right: 30, bottom: 40, left: 50 };
            const width = 350 - margin.left - margin.right;
            const height = 250 - margin.bottom - margin.top;

            const svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain(d3.extent(lengths))
                .range([0, width]);

            const histogram = d3.histogram()
                .value(d => d)
                .domain(x.domain())
                .thresholds(bins);

            const bins_data = histogram(lengths);

            const y = d3.scaleLinear()
                .domain([0, d3.max(bins_data, d => d.length)])
                .range([height, 0]);

            svg.selectAll(".bar")
                .data(bins_data)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.x0))
                .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr("y", d => y(d.length))
                .attr("height", d => height - y(d.length))
                .attr("fill", "#74b9ff")
                .on("mouseover", function(event, d) {
                    showTooltip(event, `<strong>Length: ${Math.round(d.x0)}-${Math.round(d.x1)}</strong><br>Scenes: ${d.length}`);
                })
                .on("mouseout", hideTooltip);

            svg.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y));
        }

        function updateScatterChart() {
            const container = d3.select("#scatter-chart");
            container.selectAll("*").remove();

            const sizeBy = d3.select("#scatter-size").node().value;

            const margin = { top: 20, right: 30, bottom: 40, left: 50 };
            const width = 350 - margin.left - margin.right;
            const height = 250 - margin.bottom - margin.top;

            const svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain([0, d3.max(data.scenes, d => d.goals_count)])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data.scenes, d => d.conflicts_count)])
                .range([height, 0]);

            const size = sizeBy === "length" 
                ? d3.scaleSqrt()
                    .domain(d3.extent(data.scenes, d => d.scene_length))
                    .range([3, 15])
                : () => 6;

            svg.selectAll(".dot")
                .data(data.scenes)
                .enter()
                .append("circle")
                .attr("class", "dot")
                .attr("cx", d => x(d.goals_count))
                .attr("cy", d => y(d.conflicts_count))
                .attr("r", d => sizeBy === "length" ? size(d.scene_length) : size())
                .attr("fill", "#e74c3c")
                .attr("opacity", 0.7)
                .on("mouseover", function(event, d) {
                    showTooltip(event, `<strong>${d.id}</strong><br>Goals: ${d.goals_count}<br>Conflicts: ${d.conflicts_count}<br>Length: ${d.scene_length} chars`);
                })
                .on("mouseout", hideTooltip)
                .on("click", function(event, d) {
                    d3.select("#scene-selector").node().value = d.id;
                    updateSceneDetails();
                });

            svg.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y));

            // Add axis labels
            svg.append("text")
                .attr("transform", `translate(${width/2}, ${height + 35})`)
                .style("text-anchor", "middle")
                .text("Number of Goals");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Number of Conflicts");
        }

        function updateNetworkChart() {
            const container = d3.select("#network-chart");
            container.selectAll("*").remove();

            // Check if we have conflict network data (new format)
            if (data.conflict_network && data.conflict_network.length > 0) {
                updateConflictNetworkChart(container);
            } else {
                updateGoalNetworkChart(container);
            }
        }

        function updateConflictNetworkChart(container) {
            console.log('Drawing conflict network chart');
            
            // Collect all characters from conflicts
            let allCharacters = new Set();
            data.conflict_network.forEach(conflict => {
                if (conflict.characters && Array.isArray(conflict.characters)) {
                    conflict.characters.forEach(char => allCharacters.add(char));
                }
            });
            
            // Also add characters from character_books if available
            if (data.character_books) {
                Object.keys(data.character_books).forEach(char => allCharacters.add(char));
            }
            
            // Create nodes
            const nodes = Array.from(allCharacters).map(char => ({
                id: char,
                name: char,
                books: data.character_books && data.character_books[char] ? data.character_books[char] : [],
                bookCount: data.character_books && data.character_books[char] ? data.character_books[char].length : 1
            }));

            // Create links from conflict data
            const links = [];
            data.conflict_network.forEach(conflict => {
                if (conflict.characters && Array.isArray(conflict.characters) && conflict.characters.length >= 2) {
                    // Create links between all pairs of characters in the conflict
                    for (let i = 0; i < conflict.characters.length; i++) {
                        for (let j = i + 1; j < conflict.characters.length; j++) {
                            const char1 = conflict.characters[i];
                            const char2 = conflict.characters[j];
                            
                            // Find existing link or create new one
                            let existingLink = links.find(link => 
                                (link.source === char1 && link.target === char2) ||
                                (link.source === char2 && link.target === char1)
                            );
                            
                            if (existingLink) {
                                existingLink.conflicts.push(conflict);
                                existingLink.conflictCount++;
                            } else {
                                links.push({
                                    source: char1,
                                    target: char2,
                                    conflicts: [conflict],
                                    conflictCount: 1
                                });
                            }
                        }
                    }
                }
            });

            if (nodes.length === 0) {
                container.append("div")
                    .style("text-align", "center")
                    .style("padding", "20px")
                    .style("color", "#7f8c8d")
                    .text("No character network data available");
                return;
            }

            const width = 350;
            const height = 250;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(60))
                .force('charge', d3.forceManyBody().strength(-150))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(20));

            // Color scale based on book count
            const networkColorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // Add links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#555')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.conflictCount) + 1);

            // Add nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => Math.sqrt(d.bookCount) * 2 + 6)
                .attr('fill', d => networkColorScale(d.bookCount))
                .attr('stroke', '#fff')
                .attr('stroke-width', 1)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `<strong>${d.name}</strong><br>Books: ${d.books.join(', ')}<br>Book count: ${d.bookCount}`);
                })
                .on("mouseout", hideTooltip);

            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.name)
                .attr('font-size', '9px')
                .attr('font-family', 'Arial, sans-serif')
                .attr('fill', '#333')
                .attr('text-anchor', 'middle')
                .attr('dy', -12);

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        function updateGoalNetworkChart(container) {
            const filterCategory = d3.select("#network-filter").node().value;
            const forceStrength = +d3.select("#force-slider").node().value;

            // Filter goals by category
            let filteredGoals = data.goals;
            if (filterCategory !== "all") {
                filteredGoals = data.goals.filter(g => g.category === filterCategory);
            }

            // Create nodes and links
            const characters = [...new Set(filteredGoals.map(g => g.character))];
            const categories = [...new Set(filteredGoals.map(g => g.category))];

            const nodes = [
                ...characters.map(c => ({ id: c, type: "character", group: "character" })),
                ...categories.map(c => ({ id: c, type: "category", group: "category" }))
            ];

            const links = filteredGoals.map(g => ({
                source: g.character,
                target: g.category,
                scene_id: g.scene_id
            }));

            const width = 350;
            const height = 250;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(50))
                .force("charge", d3.forceManyBody().strength(-forceStrength))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("class", "link")
                .attr("stroke-width", 1);

            const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("class", "node")
                .attr("r", d => d.type === "character" ? 8 : 12)
                .attr("fill", d => d.type === "character" ? "#3498db" : colorScale(d.id))
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `<strong>${d.id}</strong><br>Type: ${d.type}`);
                })
                .on("mouseout", hideTooltip);

            const label = svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter()
                .append("text")
                .text(d => d.id)
                .style("font-size", "10px")
                .style("text-anchor", "middle")
                .style("pointer-events", "none");

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y + 4);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function updateGoalNetworkChart() {
            const container = d3.select("#goal-network-chart");
            container.selectAll("*").remove();

            // Check if we have goals data
            if (!data || !data.goals || data.goals.length === 0) {
                container.append("div")
                    .style("text-align", "center")
                    .style("padding", "20px")
                    .style("color", "#7f8c8d")
                    .text("No character-goal data available");
                return;
            }

            const filterCategory = d3.select("#goal-network-filter").node().value;
            const forceStrength = +d3.select("#goal-force-slider").node().value;

            // Filter goals by category
            let filteredGoals = data.goals;
            if (filterCategory !== "all") {
                filteredGoals = data.goals.filter(g => g.category === filterCategory);
            }

            // Create nodes and links
            const characters = [...new Set(filteredGoals.map(g => g.character))];
            const categories = [...new Set(filteredGoals.map(g => g.category))];

            const nodes = [
                ...characters.map(c => ({ id: c, type: "character", group: "character" })),
                ...categories.map(c => ({ id: c, type: "category", group: "category" }))
            ];

            const links = filteredGoals.map(g => ({
                source: g.character,
                target: g.category,
                scene_id: g.scene_id,
                goal_text: g.goal_text
            }));

            const width = 350;
            const height = 300;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-forceStrength))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(15));

            // Color scales
            const characterColor = '#3498db';
            const categoryColors = d3.scaleOrdinal(d3.schemeCategory10);

            // Add links
            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("stroke", "#555")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", 1);

            // Add nodes
            const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", d => d.type === "character" ? 8 : 12)
                .attr("fill", d => d.type === "character" ? characterColor : categoryColors(d.id))
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .call(d3.drag()
                    .on("start", goalDragstarted)
                    .on("drag", goalDragged)
                    .on("end", goalDragended))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `<strong>${d.id}</strong><br>Type: ${d.type}`);
                })
                .on("mouseout", hideTooltip);

            // Add labels
            const label = svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter()
                .append("text")
                .text(d => d.id)
                .style("font-size", "10px")
                .style("text-anchor", "middle")
                .style("fill", "#00ff41")
                .attr("dy", -15);

            // Update positions on tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            // Drag functions for goal network
            function goalDragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function goalDragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function goalDragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function updateSceneDetails() {
            const container = d3.select("#scene-details");
            const selectedSceneId = d3.select("#scene-selector").node().value;

            if (!selectedSceneId) {
                container.html("<p>Select a scene to view details...</p>");
                return;
            }

            const scene = data.scenes.find(s => s.id === selectedSceneId);
            const sceneGoals = data.goals.filter(g => g.scene_id === selectedSceneId);
            const sceneConflicts = data.conflicts.filter(c => c.scene_id === selectedSceneId);

            let html = `
                <div class="scene-details">
                    <h3>${scene.id}</h3>
                    <p><strong>Book:</strong> ${scene.book_title}</p>
                    <p><strong>Scene Index:</strong> ${scene.scene_idx}</p>
                    <p><strong>Length:</strong> ${scene.scene_length.toLocaleString()} characters</p>
                    <p><strong>Narrator:</strong> ${scene.narrator}</p>
                    
                    <h4>Goals (${sceneGoals.length}):</h4>
                    ${sceneGoals.length > 0 ? `
                        <ul>
                            ${sceneGoals.map(g => `
                                <li>
                                    <strong>${g.character}</strong> - <span style="color: ${colorScale(g.category)}; font-weight: bold;">${g.category}</span>
                                    <br>${g.description}
                                    <br><em style="color: #666;">Evidence: ${g.evidence}</em>
                                </li>
                            `).join('')}
                        </ul>
                    ` : '<p style="color: #999; font-style: italic;">No goals identified in this scene.</p>'}
                    
                    <h4>Conflicts (${sceneConflicts.length}):</h4>
                    ${sceneConflicts.length > 0 ? `
                        <ul>
                            ${sceneConflicts.map(c => `
                                <li>
                                    <strong>${c.type}</strong> - <span style="color: ${colorScale(c.category)}; font-weight: bold;">${c.category}</span>
                                    <br>${c.description}
                                    <br><em style="color: #666;">Evidence: ${c.evidence}</em>
                                </li>
                            `).join('')}
                        </ul>
                    ` : '<p style="color: #999; font-style: italic;">No conflicts identified in this scene.</p>'}
                </div>
            `;

            container.html(html);
        }

        function showTooltip(event, content) {
            tooltip
                .style("opacity", 1)
                .html(content)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            tooltip.style("opacity", 0);
        }
    </script>
</body>
</html>
